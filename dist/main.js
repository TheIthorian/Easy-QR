/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/CanvasGrid.ts":
/*!***************************!*\
  !*** ./src/CanvasGrid.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CanvasGrid\": () => (/* binding */ CanvasGrid)\n/* harmony export */ });\n/**\r\n * Controller class for the output canvas\r\n */\r\nvar CanvasGrid = /** @class */ (function () {\r\n    /**\r\n     * @param canvasId DOM If of the canvas\r\n     * @param size How many cells wide the QR code is\r\n     */\r\n    function CanvasGrid(canvasId, size) {\r\n        this.canvasElement = document.getElementById(canvasId);\r\n        this.width = size;\r\n        this.height = size;\r\n        this.canvasElement.width = Math.min(document.body.clientWidth / 2, document.body.clientHeight / 2);\r\n        this.canvasElement.height = this.canvasElement.width;\r\n        this.tileSize = this.canvasElement.width / size;\r\n    }\r\n    /**\r\n     * Paint a cell with the given color\r\n     * @param index - Cell index\r\n     * @param color\r\n     */\r\n    CanvasGrid.prototype.fillCell = function (index, color) {\r\n        var coords = this._findPosition(index);\r\n        var x = coords[0] * this.tileSize;\r\n        var y = coords[1] * this.tileSize;\r\n        var context = this.canvasElement.getContext('2d');\r\n        context.beginPath();\r\n        context.fillStyle = color;\r\n        context.fillRect(x, y, this.tileSize, this.tileSize);\r\n        context.stroke();\r\n    };\r\n    CanvasGrid.prototype._findPosition = function (index) {\r\n        var x = index % this.width;\r\n        var y = Math.floor(index / this.width);\r\n        return [x, y];\r\n    };\r\n    CanvasGrid.prototype._findIndex = function (x, y) {\r\n        if (x >= this.width || y >= this.height || x < 0 || y < 0) {\r\n            return -1;\r\n        }\r\n        return this.width * y + x;\r\n    };\r\n    return CanvasGrid;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://my-webpack-project/./src/CanvasGrid.ts?");

/***/ }),

/***/ "./src/Polynomial.ts":
/*!***************************!*\
  !*** ./src/Polynomial.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getEDC\": () => (/* binding */ getEDC),\n/* harmony export */   \"getGeneratorPoly\": () => (/* binding */ getGeneratorPoly),\n/* harmony export */   \"polyRest\": () => (/* binding */ polyRest)\n/* harmony export */ });\n// Initialise reed-soloman generator polynomial constants\r\nvar LOG = new Uint8Array(256);\r\nvar EXP = new Uint8Array(256);\r\nfor (var exponent = 1, value = 1; exponent < 256; exponent++) {\r\n    value = value > 127 ? (value << 1) ^ 285 : value << 1;\r\n    LOG[value] = exponent % 255;\r\n    EXP[exponent % 255] = value;\r\n}\r\nfunction mul(a, b) {\r\n    return a && b ? EXP[(LOG[a] + LOG[b]) % 255] : 0;\r\n}\r\nfunction div(a, b) {\r\n    return EXP[(LOG[a] + LOG[b] * 254) % 255];\r\n}\r\nfunction polyMul(poly1, poly2) {\r\n    var coefficients = new Uint8Array(poly1.length + poly2.length - 1);\r\n    for (var index = 0; index < coefficients.length; index++) {\r\n        var coefficient = 0;\r\n        for (var p1Index = 0; p1Index <= index; p1Index++) {\r\n            var p2Index = index - p1Index;\r\n            coefficient ^= mul(poly1[p1Index], poly2[p2Index]);\r\n        }\r\n        coefficients[index] = coefficient;\r\n    }\r\n    return coefficients;\r\n}\r\nfunction polyRest(dividend, divisor) {\r\n    var quotientLength = dividend.length - divisor.length + 1;\r\n    var rest = new Uint8Array(dividend);\r\n    var _loop_1 = function (count) {\r\n        if (rest[0]) {\r\n            var factor = div(rest[0], divisor[0]);\r\n            var subtr_1 = new Uint8Array(rest.length);\r\n            subtr_1.set(polyMul(divisor, new Uint8Array([factor])), 0);\r\n            rest = rest.map(function (value, index) { return value ^ subtr_1[index]; }).slice(1);\r\n        }\r\n        else {\r\n            rest = rest.slice(1);\r\n        }\r\n    };\r\n    for (var count = 0; count < quotientLength; count++) {\r\n        _loop_1(count);\r\n    }\r\n    return rest;\r\n}\r\nfunction getGeneratorPoly(degree) {\r\n    var lastPoly = new Uint8Array([1]);\r\n    for (var i = 0; i < degree; i++) {\r\n        lastPoly = polyMul(lastPoly, new Uint8Array([1, EXP[i]]));\r\n    }\r\n    return lastPoly;\r\n}\r\nfunction getEDC(data, codewords) {\r\n    var degree = codewords - data.length;\r\n    var messagePoly = new Uint8Array(codewords);\r\n    messagePoly.set(data, 0);\r\n    return polyRest(messagePoly, getGeneratorPoly(degree));\r\n}\r\n\n\n//# sourceURL=webpack://my-webpack-project/./src/Polynomial.ts?");

/***/ }),

/***/ "./src/QR.ts":
/*!*******************!*\
  !*** ./src/QR.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"QR\": () => (/* binding */ QR)\n/* harmony export */ });\n/* harmony import */ var _QRCode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./QRCode */ \"./src/QRCode.ts\");\n\r\n/**\r\n * Controller class to generate and display QR codes.\r\n */\r\nvar QR = /** @class */ (function () {\r\n    function QR(canvasId, data, mode, correctionLevel) {\r\n        if (mode === void 0) { mode = 'Byte'; }\r\n        if (correctionLevel === void 0) { correctionLevel = 'L'; }\r\n        this.qrCode = new _QRCode__WEBPACK_IMPORTED_MODULE_0__.QRCode(canvasId, data, mode, correctionLevel);\r\n    }\r\n    QR.prototype.getCanvasId = function () {\r\n        return this.qrCode.canvasId;\r\n    };\r\n    QR.prototype.setCanvasId = function (canvasId) {\r\n        this.qrCode.canvasId = canvasId;\r\n        return this.qrCode.canvasId;\r\n    };\r\n    QR.prototype.getMode = function () {\r\n        return this.qrCode.mode;\r\n    };\r\n    // setMode(mode) {\r\n    //     if (!MODES[mode]) {\r\n    //         throw 'Invalid mode';\r\n    //     } else {\r\n    //         this.qrCode.mode = mode;\r\n    //         return this.qrCode.mode;\r\n    //     }\r\n    // }\r\n    QR.prototype.getCorrectionLevel = function () {\r\n        return this.qrCode.correctionLevel;\r\n    };\r\n    // setCorrectionLevel(correctionLevel) {\r\n    //     if (!CORRECTION_LEVELS[correctionLevel]) {\r\n    //         throw 'Invalid correction level';\r\n    //     } else {\r\n    //         this.qrCode.correctionLevel = correctionLevel;\r\n    //         return this.qrCode.correctionLevel;\r\n    //     }\r\n    // }\r\n    QR.prototype.getVersion = function () {\r\n        return this.qrCode.version;\r\n    };\r\n    QR.prototype.getSize = function () {\r\n        return this.qrCode.size;\r\n    };\r\n    QR.prototype.getCode = function () {\r\n        return this.qrCode.generateCode();\r\n    };\r\n    // getModeRegex(mode) {\r\n    //     if (!MODES[mode]) {\r\n    //         throw 'Invalid mode';\r\n    //     } else {\r\n    //         return MODE_REGEX[mode];\r\n    //     }\r\n    // }\r\n    QR.prototype.printCodeToCanvas = function (canvasId) {\r\n        // if (canvasId) {\r\n        //     this.qrCode.setCanvasId(canvasId);\r\n        // }\r\n        this.qrCode.display();\r\n    };\r\n    return QR;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://my-webpack-project/./src/QR.ts?");

/***/ }),

/***/ "./src/QRArray.ts":
/*!************************!*\
  !*** ./src/QRArray.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"QRArray\": () => (/* binding */ QRArray)\n/* harmony export */ });\n/* harmony import */ var _Polynomial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Polynomial */ \"./src/Polynomial.ts\");\n\r\n/*\r\nTODO:\r\n - Remove old comments and logs\r\n - Add finder patterns for v2+\r\n - Add all other masks and optimise\r\n - Does not work for v22, H: Hello there, I need to make this a large qr code so that more things are used Hello there, I need to make this a large qr code so that more things are used Hello there, I need to make this a large qr code so that more things are used Hello there, I need to make this a large qr code so that more things are used Hello there, I need to make this a large qr code so that more things are used r code so that more things are used\r\n  > Incorrect codewords. I think this is due to the cahracter length map\r\n*/\r\nvar QRArray = /** @class */ (function () {\r\n    function QRArray(qrCode, codewords) {\r\n        this.data = codewords;\r\n        this.correctionLevel = qrCode.correctionLevel;\r\n        this.array = [];\r\n        this.size = qrCode.size;\r\n        this.version = qrCode.version;\r\n        for (var i = 0; i < this.size * this.size; i++) {\r\n            this.array[i] = '';\r\n        }\r\n    }\r\n    QRArray.prototype.coordToIndex = function (x, y) {\r\n        return this.size * y + x;\r\n    };\r\n    QRArray.prototype.indexToCorrd = function (i) {\r\n        return [i % this.size, Math.floor(i / this.size) + 1];\r\n    };\r\n    QRArray.prototype.addTimingPattern = function () {\r\n        var toggle = true;\r\n        for (var i = 0; i < this.size; i++) {\r\n            this.array[this.coordToIndex(6, i)] = toggle ? '1' : '0';\r\n            toggle = !toggle;\r\n        }\r\n        toggle = true;\r\n        for (var i = 0; i < this.size; i++) {\r\n            this.array[this.coordToIndex(i, 6)] = toggle ? '1' : '0';\r\n            toggle = !toggle;\r\n        }\r\n    };\r\n    QRArray.prototype.addFinderPattern = function () {\r\n        var LARGE_SQURE = [\r\n            ['1', '1', '1', '1', '1', '1', '1'],\r\n            ['1', '0', '0', '0', '0', '0', '1'],\r\n            ['1', '0', '1', '1', '1', '0', '1'],\r\n            ['1', '0', '1', '1', '1', '0', '1'],\r\n            ['1', '0', '1', '1', '1', '0', '1'],\r\n            ['1', '0', '0', '0', '0', '0', '1'],\r\n            ['1', '1', '1', '1', '1', '1', '1'],\r\n        ];\r\n        var startPositions = [\r\n            0,\r\n            this.size - LARGE_SQURE.length,\r\n            this.size * (this.size - LARGE_SQURE.length),\r\n        ];\r\n        for (var _i = 0, startPositions_1 = startPositions; _i < startPositions_1.length; _i++) {\r\n            var position = startPositions_1[_i];\r\n            for (var i = 0; i < LARGE_SQURE.length; i++) {\r\n                for (var j = 0; j < LARGE_SQURE.length; j++) {\r\n                    this.array[position + i + this.size * j] = LARGE_SQURE[i][j];\r\n                }\r\n            }\r\n        }\r\n        // Additional white space around each square\r\n        // Top left\r\n        for (var i = 0; i < 9; i++) {\r\n            this.array[this.coordToIndex(7, i)] = '0';\r\n            this.array[this.coordToIndex(i, 7)] = '0';\r\n            this.array[this.coordToIndex(8, i)] = '0';\r\n            this.array[this.coordToIndex(i, 8)] = '0';\r\n        }\r\n        this.array[this.coordToIndex(8, 6)] = '1'; // Always here\r\n        this.array[this.coordToIndex(6, 8)] = '1';\r\n        // Top right\r\n        for (var i = 0; i < 8; i++) {\r\n            this.array[this.coordToIndex(this.size - 8 + i, 7)] = '0';\r\n            this.array[this.coordToIndex(this.size - 8, i)] = '0';\r\n        }\r\n        // Bottom left\r\n        for (var i = 0; i < 9; i++) {\r\n            this.array[this.coordToIndex(7, this.size - i)] = '0';\r\n            this.array[this.coordToIndex(i, this.size - 8)] = '0';\r\n        }\r\n        this.array[this.coordToIndex(8, this.size - 8)] = '1';\r\n    };\r\n    QRArray.prototype.addSmallFinderPatterns = function () {\r\n        var patternLocations = this.getAlignmentPatternPositions();\r\n        for (var x = 0; x < patternLocations.length; x++) {\r\n            for (var y = 0; y < patternLocations.length; y++) {\r\n                if ((x == 0 && y == 0) || // // Always blocked by the large finder pattern\r\n                    (x == 0 && y == patternLocations.length - 1) ||\r\n                    (x == patternLocations.length - 1 && y == 0)) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    this.addSmallerFinderSquare(patternLocations[x], patternLocations[y]);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    QRArray.prototype.addSmallerFinderSquare = function (x, y) {\r\n        var SMALL_SQUARE = [\r\n            ['1', '1', '1', '1', '1'],\r\n            ['1', '0', '0', '0', '1'],\r\n            ['1', '0', '1', '0', '1'],\r\n            ['1', '0', '0', '0', '1'],\r\n            ['1', '1', '1', '1', '1'],\r\n        ];\r\n        for (var i = 0; i < 5; i++) {\r\n            for (var j = 0; j < 5; j++) {\r\n                this.array[this.coordToIndex(x - 2 + i, y - 2 + j)] = SMALL_SQUARE[i][j];\r\n            }\r\n        }\r\n    };\r\n    QRArray.prototype.getAlignmentPatternPositions = function () {\r\n        // TODO: Make this return a ist of points instead\r\n        if (this.version == 1)\r\n            return [];\r\n        else {\r\n            var numAlign = Math.floor(this.version / 7) + 2;\r\n            var step = this.version == 32\r\n                ? 26\r\n                : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\r\n            var result = [6];\r\n            for (var pos = this.size - 7; result.length < numAlign; pos -= step)\r\n                result.splice(1, 0, pos);\r\n            return result;\r\n        }\r\n    };\r\n    QRArray.prototype.addVersionInformation = function () {\r\n        if (this.version < 7) {\r\n            return;\r\n        }\r\n        var data = this.getVersionInformation(this.version);\r\n        for (var row = 0; row < 6; row++) {\r\n            for (var column = 0; column < 3; column++) {\r\n                // console.log(`x: ${row}, y: ${this.size - 11 + column}, bit: ${data[3*row + column]}`);\r\n                this.array[this.coordToIndex(row, this.size - 11 + column)] =\r\n                    data[3 * row + column].toString();\r\n                this.array[this.coordToIndex(this.size - 11 + column, row)] =\r\n                    data[3 * row + column].toString();\r\n            }\r\n        }\r\n    };\r\n    QRArray.prototype.getVersionInformation = function (version) {\r\n        var VERSION_DIVISOR = new Uint8Array([1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1]);\r\n        var polyArray = version.toString(2).padStart(6, '0') + '000000000000';\r\n        var poly = Uint8Array.from(polyArray.split('').map(function (char) { return parseInt(char); }));\r\n        poly.set((0,_Polynomial__WEBPACK_IMPORTED_MODULE_0__.polyRest)(poly, VERSION_DIVISOR), 6);\r\n        return poly;\r\n    };\r\n    QRArray.prototype.placeCodewordHorizontalPair = function (index, x, y) {\r\n        if (x < 0 || y < 0) {\r\n            return;\r\n        }\r\n        // console.log(index, x, y, this.data[index]);\r\n        this.array[this.coordToIndex(x, y)] = this.data[index];\r\n        // console.log(index + 1, x - 1, y, this.data[index + 1]);\r\n        this.array[this.coordToIndex(x - 1, y)] = this.data[index + 1];\r\n    };\r\n    QRArray.prototype.placeCodewordPair = function (index, x, y) {\r\n        // console.log(index, x, y, this.data[index]);\r\n        this.array[this.coordToIndex(x, y)] = this.data[index];\r\n    };\r\n    QRArray.prototype.placeCodewordVerticalPair = function (index, x, y, goingUp) {\r\n        var direction = goingUp ? 1 : -1;\r\n        this.array[this.coordToIndex(x, y)] = this.data[index];\r\n        for (var i = 1; i <= 6; i++) {\r\n            this.array[this.coordToIndex(x, y + direction * i)] = this.data[index + i];\r\n        }\r\n        index += 6;\r\n        y += 6 * direction;\r\n    };\r\n    QRArray.prototype.addCodewords = function () {\r\n        var _a, _b, _c;\r\n        // position initialized to bottom right\r\n        var x_pos, y_pos, goingUp;\r\n        goingUp = true;\r\n        x_pos = this.size - 1;\r\n        y_pos = this.size - 1;\r\n        var alignmetPatternPositions = this.getAlignmentPatternPositions();\r\n        // console.log(this.getAlignmentPatternPositions());\r\n        // console.log(this.version, this.data.length);\r\n        for (var i = 0; i < this.data.length; i += 2) {\r\n            if (i == 0) {\r\n                this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n                y_pos--;\r\n                continue;\r\n            }\r\n            if (goingUp) {\r\n                if (this.version >= 7 && y_pos == 7 && x_pos == this.size - 9) {\r\n                    // At version info\r\n                    _a = this.skipVersionInfo(i, x_pos, y_pos, goingUp), i = _a[0], x_pos = _a[1], y_pos = _a[2], goingUp = _a[3];\r\n                }\r\n                else if ((y_pos == 9 && (x_pos > this.size - 8 || x_pos <= 8)) || y_pos == 0) {\r\n                    // At bounary\r\n                    _b = this.placeBoundaryCells(i, x_pos, y_pos, goingUp), i = _b[0], x_pos = _b[1], y_pos = _b[2], goingUp = _b[3];\r\n                }\r\n                else if (alignmetPatternPositions.includes(y_pos - 3) &&\r\n                    alignmetPatternPositions.includes(x_pos - 2)) {\r\n                    // At alignment pattern\r\n                    this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n                    y_pos -= 6;\r\n                }\r\n                else if (this.isAtAlignmentPattern(x_pos, y_pos, alignmetPatternPositions, goingUp)) {\r\n                    // At alignment pattern\r\n                    // console.log('Alignment pattern up', x_pos, y_pos);\r\n                    this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n                    i += 2;\r\n                    x_pos--;\r\n                    y_pos--;\r\n                    for (var _ = 0; _ < 5; _++) {\r\n                        this.placeCodewordPair(i, x_pos, y_pos);\r\n                        y_pos--;\r\n                        i++;\r\n                    }\r\n                    i -= 2;\r\n                    x_pos++;\r\n                }\r\n                else if (y_pos == 6) {\r\n                    // Skip over timing pattern\r\n                    y_pos--;\r\n                    this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n                    y_pos--;\r\n                }\r\n                else {\r\n                    this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n                    y_pos--;\r\n                }\r\n            }\r\n            else if (!goingUp) {\r\n                // Going down\r\n                if (y_pos == this.size - 1 && x_pos == 10) {\r\n                    // At lower timing boundary\r\n                    this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n                    x_pos = 8;\r\n                    y_pos = this.size - 9;\r\n                    goingUp = true;\r\n                }\r\n                else if ((y_pos == this.size - 9 && x_pos <= 8) || y_pos == this.size - 1) {\r\n                    // At bounary\r\n                    _c = this.placeBoundaryCells(i, x_pos, y_pos, goingUp), i = _c[0], x_pos = _c[1], y_pos = _c[2], goingUp = _c[3];\r\n                }\r\n                else if (this.isAtAlignmentPattern(x_pos, y_pos, alignmetPatternPositions, goingUp)) {\r\n                    // console.log('Alignment pattern down:', x_pos, y_pos);\r\n                    this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n                    y_pos += 6;\r\n                }\r\n                else if (y_pos == 6) {\r\n                    // Skip over timing pattern\r\n                    y_pos++;\r\n                    this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n                    y_pos++;\r\n                }\r\n                else {\r\n                    this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n                    y_pos++;\r\n                }\r\n            }\r\n            if (x_pos < 0) {\r\n                return;\r\n            }\r\n        }\r\n    };\r\n    QRArray.prototype.skipVersionInfo = function (i, x_pos, y_pos, goingUp) {\r\n        if (goingUp) {\r\n            this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n            y_pos = 0;\r\n            x_pos = this.size - 12;\r\n            i++;\r\n            for (var j = 0; j < 6; j++) {\r\n                this.array[this.coordToIndex(x_pos, y_pos + j)] = this.data[i];\r\n                // console.log(x_pos, y_pos + j, i);\r\n                i++;\r\n            }\r\n            y_pos = 7;\r\n            x_pos = this.size - 11;\r\n            this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n            y_pos++;\r\n            goingUp = false;\r\n            return [i, x_pos, y_pos, goingUp];\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    };\r\n    QRArray.prototype.placeBoundaryCells = function (i, x_pos, y_pos, goingUp) {\r\n        if (goingUp) {\r\n            this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n            i += 2;\r\n            // Vertical timing pattern\r\n            x_pos == 8 && y_pos == 9 ? (x_pos -= 3) : (x_pos -= 2);\r\n            goingUp = false;\r\n            this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n            y_pos++;\r\n            return [i, x_pos, y_pos, goingUp];\r\n        }\r\n        else {\r\n            this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n            x_pos -= 2;\r\n            i += 2;\r\n            goingUp = true;\r\n            this.placeCodewordHorizontalPair(i, x_pos, y_pos);\r\n            y_pos--;\r\n            return [i, x_pos, y_pos, goingUp];\r\n        }\r\n    };\r\n    QRArray.prototype.isAtAlignmentPattern = function (x_pos, y_pos, alignmetPatternPositions, goingUp) {\r\n        if (goingUp) {\r\n            return (alignmetPatternPositions.includes(y_pos - 3) &&\r\n                alignmetPatternPositions.includes(x_pos + 2) &&\r\n                !(alignmetPatternPositions[0] == x_pos + 2 &&\r\n                    alignmetPatternPositions[0] == y_pos - 3) &&\r\n                !(alignmetPatternPositions[0] == x_pos + 2 &&\r\n                    alignmetPatternPositions[alignmetPatternPositions.length - 1] == y_pos - 3) &&\r\n                !(alignmetPatternPositions[0] == y_pos - 3 &&\r\n                    alignmetPatternPositions[alignmetPatternPositions.length - 1] == x_pos + 2));\r\n        }\r\n        else {\r\n            return (alignmetPatternPositions.includes(y_pos + 3) &&\r\n                (alignmetPatternPositions.includes(x_pos) ||\r\n                    alignmetPatternPositions.includes(x_pos + 1)) &&\r\n                !(alignmetPatternPositions[0] == x_pos && alignmetPatternPositions[0] == y_pos + 3) &&\r\n                !(alignmetPatternPositions[0] == x_pos &&\r\n                    alignmetPatternPositions[alignmetPatternPositions.length - 1] == y_pos + 3) &&\r\n                !(alignmetPatternPositions[0] == x_pos + 1 &&\r\n                    alignmetPatternPositions[alignmetPatternPositions.length - 1] == y_pos + 3) &&\r\n                !(alignmetPatternPositions[0] == y_pos + 3 &&\r\n                    alignmetPatternPositions[alignmetPatternPositions.length - 1] == x_pos));\r\n        }\r\n    };\r\n    QRArray.prototype.applyMasks = function () {\r\n        //https://dev.to/maxart2501/let-s-develop-a-qr-code-generator-part-v-masking-30dl\r\n        //https://www.nayuki.io/page/creating-a-qr-code-step-by-step\r\n        for (var i = 0; i < this.array.length; i++) {\r\n            if (i % 2 == 0) {\r\n                this.array[i] = (parseInt(this.array[i]) ^ 1).toString();\r\n            }\r\n            else {\r\n                this.array[i] = (parseInt(this.array[i]) ^ 0).toString();\r\n            }\r\n        }\r\n    };\r\n    QRArray.prototype.addErrorLevel = function () {\r\n        var maskIndex = 0;\r\n        var EDC_ORDER = 'MLHQ';\r\n        var FORMAT_DIVISOR = new Uint8Array([1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1]);\r\n        var FORMAT_MASK = new Uint8Array([1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]);\r\n        var formatPoly = new Uint8Array(15);\r\n        var errorLevelIndex = EDC_ORDER.indexOf(this.correctionLevel);\r\n        formatPoly[0] = errorLevelIndex >> 1;\r\n        formatPoly[1] = errorLevelIndex & 1;\r\n        formatPoly[2] = maskIndex >> 2;\r\n        formatPoly[3] = (maskIndex >> 1) & 1;\r\n        formatPoly[4] = maskIndex & 1;\r\n        var rest = (0,_Polynomial__WEBPACK_IMPORTED_MODULE_0__.polyRest)(formatPoly, FORMAT_DIVISOR);\r\n        formatPoly.set(rest, 5);\r\n        var maskedFormatPoly = formatPoly.map(function (bit, index) { return bit ^ FORMAT_MASK[index]; });\r\n        for (var i = 0; i < 7; i++) {\r\n            var val = void 0;\r\n            if (maskedFormatPoly[i] == 254) {\r\n                val = '1';\r\n            }\r\n            else if (maskedFormatPoly[i] == 255) {\r\n                val = '0';\r\n            }\r\n            else {\r\n                val = maskedFormatPoly[i].toString();\r\n            }\r\n            var dx = 0;\r\n            if (i > 5) {\r\n                dx = 1;\r\n            }\r\n            this.array[this.coordToIndex(i + dx, 8)] = val; // Top left - bottom\r\n            this.array[this.coordToIndex(8, this.size - i - 1)] = val; // Bottom left - right\r\n            // console.log(i, val);\r\n        }\r\n        for (var i = 7; i < 15; i++) {\r\n            var val = void 0;\r\n            if (maskedFormatPoly[i] == 254) {\r\n                val = '1';\r\n            }\r\n            else if (maskedFormatPoly[i] == 255) {\r\n                val = '0';\r\n            }\r\n            else {\r\n                val = maskedFormatPoly[i].toString();\r\n            }\r\n            var dy = 0;\r\n            if (i > 8) {\r\n                dy = 1;\r\n            }\r\n            this.array[this.coordToIndex(8, 15 - i - dy)] = val; // Top left - right\r\n            this.array[this.coordToIndex(this.size - 15 + i, 8)] = val; // Top right - bottom\r\n        }\r\n    };\r\n    QRArray.prototype.addAlternating = function () {\r\n        for (var i = 0; i < this.size * this.size; i++) {\r\n            this.array[i] = i % 2 ? '0' : '1';\r\n        }\r\n    };\r\n    return QRArray;\r\n}());\r\n\r\nvar MASK_FUNCTIONS = [\r\n    function (row, column) { return ((row + column) & 1) === 0; },\r\n    function (row, column) { return (row & 1) === 0; },\r\n    function (row, column) { return column % 3 === 0; },\r\n    function (row, column) { return (row + column) % 3 === 0; },\r\n    function (row, column) { return (((row >> 1) + Math.floor(column / 3)) & 1) === 0; },\r\n    function (row, column) { return ((row * column) & 1) + ((row * column) % 3) === 0; },\r\n    function (row, column) { return ((((row * column) & 1) + ((row * column) % 3)) & 1) === 0; },\r\n    function (row, column) { return ((((row + column) & 1) + ((row * column) % 3)) & 1) === 0; },\r\n];\r\n\n\n//# sourceURL=webpack://my-webpack-project/./src/QRArray.ts?");

/***/ }),

/***/ "./src/QRCode.ts":
/*!***********************!*\
  !*** ./src/QRCode.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"QRCode\": () => (/* binding */ QRCode)\n/* harmony export */ });\n/* harmony import */ var _CanvasGrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasGrid */ \"./src/CanvasGrid.ts\");\n/* harmony import */ var _Polynomial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Polynomial */ \"./src/Polynomial.ts\");\n/* harmony import */ var _QRArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./QRArray */ \"./src/QRArray.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"./src/util.ts\");\n// import { CELL_COLORS, DEFAULT_COLOR } from './constants.js';\r\nvar CELL_COLORS = {\r\n    1: '#000000',\r\n    0: '#FFFFFF',\r\n};\r\nvar DEFAULT_COLOR = '#FF0000';\r\n\r\n\r\n\r\n\r\n/*\r\nTODO:\r\n - Remove old comments and logs\r\n - Versions with 2 groups do not work\r\n - Small alignment squares do not always work. E.g. For larger codes\r\n - v3+ doesn't seem to work on q or h mode\r\n*/\r\nvar CORRECTION_LEVELS = {\r\n    L: 0.07,\r\n    M: 0.15,\r\n    Q: 0.25,\r\n    H: 0.3,\r\n};\r\nvar MODES = {\r\n    Numeric: '0001',\r\n    Alphanumeric: '0010',\r\n    Byte: '0100',\r\n    Kanji: '1000',\r\n    ECI: '0111',\r\n};\r\nvar CHARACTER_LENGTH_MAP = {\r\n    Numeric: function (version) {\r\n        if (version < 10) {\r\n            return 10;\r\n        }\r\n        else if (version < 17) {\r\n            return 12;\r\n        }\r\n        else {\r\n            return 14;\r\n        }\r\n    },\r\n    Alphanumeric: function (version) {\r\n        if (version < 10) {\r\n            return 9;\r\n        }\r\n        else if (version < 17) {\r\n            return 11;\r\n        }\r\n        else {\r\n            return 13;\r\n        }\r\n    },\r\n    Byte: function (version) {\r\n        if (version < 10) {\r\n            return 8;\r\n        }\r\n        else if (version < 17) {\r\n            return 16;\r\n        }\r\n        else {\r\n            return 16;\r\n        }\r\n    },\r\n    Kanji: function (version) {\r\n        if (version < 10) {\r\n            return 8;\r\n        }\r\n        else if (version < 17) {\r\n            return 10;\r\n        }\r\n        else {\r\n            return 12;\r\n        }\r\n    },\r\n    ECI: function (version) {\r\n        return 0;\r\n    },\r\n};\r\n// Depending on the correction level (L,M,Q,H) or the mode (Numeric, Alphanumeric, Byte, Kanji, ECI),\r\n// there is a limit to the number of characters that can fit on each of the 40 QR code sizes\r\n// This structure hold data for each of the QR code sizes, depending on the correction level and mode.\r\n// https://www.thonky.com/qr-code-tutorial/error-correction-table\r\n/*  totalDataCodewords:     Number of code words\r\n    ECCodeWordsPerBlock:    Number EC codewords per block\r\n    blocksInGroup1:         Number of blocks in group 1\r\n    codewordsInGroup1Block: Number of codewords in a group 1 block\r\n    blocksInGroup2:         Number of blocks in group 2\r\n    codewordsInGroup2Block: Number of codewords in a group 2 block\r\n    ModeSize:               The maximum number of characters\r\n*/\r\nvar VERSION_DATA = {\r\n    L: {\r\n        totalDataCodewords: [\r\n            19, 34, 55, 80, 108, 136, 156, 194, 232, 274, 324, 370, 428, 461, 523, 589, 647, 721,\r\n            795, 861, 932, 1006, 1094, 1174, 1276, 1370, 1468, 1531, 1631, 1735, 1843, 1955, 2071,\r\n            2191, 2306, 2434, 2566, 2702, 2812, 2956, 1276,\r\n        ],\r\n        ECCodeWordsPerBlock: [\r\n            7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28,\r\n            30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\r\n        ],\r\n        blocksInGroup1: [\r\n            1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 4, 2, 4, 3, 5, 5, 1, 5, 3, 3, 4, 2, 4, 6, 8, 10, 8, 3, 7,\r\n            5, 13, 17, 17, 13, 12, 6, 17, 4, 20, 19, 20,\r\n        ],\r\n        codewordsInGroup1Block: [\r\n            19, 34, 55, 80, 108, 68, 78, 97, 116, 68, 81, 92, 107, 115, 87, 98, 107, 120, 113, 107,\r\n            116, 111, 121, 117, 106, 114, 122, 117, 116, 115, 115, 115, 115, 115, 121, 121, 122,\r\n            122, 117, 118, 15,\r\n        ],\r\n        blocksInGroup2: [\r\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 1, 1, 1, 5, 1, 4, 5, 4, 7, 5, 4, 4, 2, 4, 10, 7,\r\n            10, 3, 0, 1, 6, 7, 14, 4, 18, 4, 6, 61,\r\n        ],\r\n        codewordsInGroup2Block: [\r\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 93, 0, 116, 88, 99, 108, 121, 114, 108, 117, 112, 122,\r\n            118, 107, 115, 123, 118, 117, 116, 116, 0, 116, 116, 122, 122, 123, 123, 118, 119, 16,\r\n        ],\r\n        ModeSize: {\r\n            // Max number of characters per version, starting at version=1\r\n            Numeric: [\r\n                41, 77, 127, 187, 255, 322, 370, 461, 552, 652, 772, 883, 1022, 1101, 1250, 1408,\r\n                1548, 1725, 1903, 2061, 2232, 2409, 2620, 2812, 3057, 3283, 3517, 3669, 3909, 4158,\r\n                4417, 4686, 4965, 5253, 5529, 5836, 6153, 6479, 6743, 7089,\r\n            ],\r\n            Alphanumeric: [\r\n                25, 47, 77, 114, 154, 195, 224, 279, 335, 395, 468, 535, 619, 667, 758, 854, 938,\r\n                1046, 1153, 1249, 1352, 1460, 1588, 1704, 1853, 1990, 2132, 2223, 2369, 2520, 2677,\r\n                2840, 3009, 3183, 3351, 3537, 3729, 3927, 4087, 4296,\r\n            ],\r\n            Byte: [\r\n                17, 32, 53, 78, 106, 134, 154, 192, 230, 271, 321, 367, 425, 458, 520, 586, 644,\r\n                718, 792, 858, 929, 1003, 1091, 1171, 1273, 1367, 1465, 1528, 1628, 1732, 1840,\r\n                1952, 2068, 2188, 2303, 2431, 2563, 2699, 2809, 2953,\r\n            ],\r\n            Kanji: [\r\n                10, 20, 32, 48, 65, 82, 95, 118, 141, 167, 198, 226, 262, 282, 320, 361, 397, 442,\r\n                488, 528, 572, 618, 672, 721, 784, 842, 902, 940, 1002, 1066, 1132, 1201, 1273,\r\n                1347, 1417, 1496, 1577, 1661, 1729, 1817,\r\n            ],\r\n            ECI: [0],\r\n        },\r\n    },\r\n    M: {\r\n        totalDataCodewords: [\r\n            16, 28, 44, 64, 86, 108, 124, 154, 182, 216, 254, 290, 334, 365, 415, 453, 507, 563,\r\n            627, 669, 714, 782, 860, 914, 1000, 1062, 1128, 1193, 1267, 1373, 1455, 1541, 1631,\r\n            1725, 1812, 1914, 1992, 2102, 2216, 2334,\r\n        ],\r\n        ECCodeWordsPerBlock: [\r\n            10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28,\r\n            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\r\n        ],\r\n        blocksInGroup1: [\r\n            1, 1, 1, 2, 2, 4, 4, 2, 3, 4, 1, 6, 8, 4, 5, 7, 10, 9, 3, 3, 17, 17, 4, 6, 8, 19, 22, 3,\r\n            21, 19, 2, 10, 14, 14, 12, 6, 29, 13, 40, 18,\r\n        ],\r\n        codewordsInGroup1Block: [\r\n            16, 28, 44, 32, 43, 27, 31, 38, 36, 43, 50, 36, 37, 40, 41, 45, 46, 43, 44, 41, 42, 46,\r\n            47, 45, 47, 46, 45, 45, 45, 47, 46, 46, 46, 46, 47, 47, 46, 46, 47, 47,\r\n        ],\r\n        blocksInGroup2: [\r\n            0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 4, 2, 1, 5, 5, 3, 1, 4, 11, 13, 0, 0, 14, 14, 13, 4, 3,\r\n            23, 7, 10, 29, 23, 21, 23, 26, 34, 14, 32, 7, 31,\r\n        ],\r\n        codewordsInGroup2Block: [\r\n            0, 0, 0, 0, 0, 0, 0, 39, 37, 44, 51, 37, 38, 41, 42, 46, 47, 44, 45, 42, 0, 0, 48, 46,\r\n            48, 47, 46, 46, 46, 48, 47, 47, 47, 47, 48, 48, 47, 47, 48, 48,\r\n        ],\r\n        ModeSize: {\r\n            Numeric: [\r\n                34, 63, 101, 149, 202, 255, 293, 365, 432, 513, 604, 691, 796, 871, 991, 1082, 1212,\r\n                1346, 1500, 1600, 1708, 1872, 2059, 2188, 2395, 2544, 2701, 2857, 3035, 3289, 3486,\r\n                3693, 3909, 4134, 4343, 4588, 4775, 5039, 5313, 5596,\r\n            ],\r\n            Alphanumeric: [\r\n                20, 38, 61, 90, 122, 154, 178, 221, 262, 311, 366, 419, 483, 528, 600, 656, 734,\r\n                816, 909, 970, 1035, 1134, 1248, 1326, 1451, 1542, 1637, 1732, 1839, 1994, 2113,\r\n                2238, 2369, 2506, 2632, 2780, 2894, 3054, 3220, 3391,\r\n            ],\r\n            Byte: [\r\n                14, 26, 42, 62, 84, 106, 122, 152, 180, 213, 251, 287, 331, 362, 412, 450, 504, 560,\r\n                624, 666, 711, 779, 857, 911, 997, 1059, 1125, 1190, 1264, 1370, 1452, 1538, 1628,\r\n                1722, 1809, 1911, 1989, 2099, 2213, 2331,\r\n            ],\r\n            Kanji: [\r\n                8, 16, 26, 38, 52, 65, 75, 93, 111, 131, 155, 177, 204, 223, 254, 277, 310, 345,\r\n                384, 410, 438, 480, 528, 561, 614, 652, 692, 732, 778, 843, 894, 947, 1002, 1060,\r\n                1113, 1176, 1224, 1292, 1362, 1435,\r\n            ],\r\n            ECI: [0],\r\n        },\r\n    },\r\n    Q: {\r\n        totalDataCodewords: [\r\n            13, 22, 34, 48, 62, 76, 88, 110, 132, 154, 180, 206, 244, 261, 295, 325, 367, 397, 445,\r\n            485, 512, 568, 614, 664, 718, 754, 808, 871, 911, 985, 1033, 1115, 1171, 1231, 1286,\r\n            1354, 1426, 1502, 1582, 1666,\r\n        ],\r\n        ECCodeWordsPerBlock: [\r\n            13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30,\r\n            30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\r\n        ],\r\n        blocksInGroup1: [\r\n            1, 1, 2, 2, 2, 4, 2, 4, 4, 6, 4, 4, 8, 11, 5, 15, 1, 17, 17, 15, 17, 7, 11, 11, 7, 28,\r\n            8, 4, 1, 15, 42, 10, 29, 44, 39, 46, 49, 48, 43, 34,\r\n        ],\r\n        codewordsInGroup1Block: [\r\n            13, 22, 17, 24, 15, 19, 14, 18, 16, 19, 22, 20, 20, 16, 24, 19, 22, 22, 21, 24, 22, 24,\r\n            24, 24, 24, 22, 23, 24, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\r\n        ],\r\n        blocksInGroup2: [\r\n            0, 0, 0, 0, 2, 0, 4, 2, 4, 2, 4, 6, 4, 5, 7, 2, 15, 1, 4, 5, 6, 16, 14, 16, 22, 6, 26,\r\n            31, 37, 25, 1, 35, 19, 7, 14, 10, 10, 14, 22, 34,\r\n        ],\r\n        codewordsInGroup2Block: [\r\n            0, 0, 0, 0, 16, 0, 15, 19, 17, 20, 23, 21, 21, 17, 25, 20, 23, 23, 22, 25, 23, 25, 25,\r\n            25, 25, 23, 24, 25, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\r\n        ],\r\n        ModeSize: {\r\n            Numeric: [\r\n                27, 48, 77, 111, 144, 178, 207, 259, 312, 364, 427, 489, 580, 621, 703, 775, 876,\r\n                948, 1063, 1159, 1224, 1358, 1468, 1588, 1718, 1804, 1933, 2085, 2181, 2358, 2473,\r\n                2670, 2805, 2949, 3081, 3244, 3417, 3599, 3791, 3993,\r\n            ],\r\n            Alphanumeric: [\r\n                16, 29, 47, 67, 87, 108, 125, 157, 189, 221, 259, 296, 352, 376, 426, 470, 531, 574,\r\n                644, 702, 742, 823, 890, 963, 1041, 1094, 1172, 1263, 1322, 1429, 1499, 1618, 1700,\r\n                1787, 1867, 1966, 2071, 2181, 2298, 2420,\r\n            ],\r\n            Byte: [\r\n                11, 20, 32, 46, 60, 74, 86, 108, 130, 151, 177, 203, 241, 258, 292, 322, 364, 394,\r\n                442, 482, 509, 565, 611, 661, 715, 751, 805, 868, 908, 982, 1030, 1112, 1168, 1228,\r\n                1283, 1351, 1423, 1499, 1579, 1663,\r\n            ],\r\n            Kanji: [\r\n                7, 12, 20, 28, 37, 45, 53, 66, 80, 93, 109, 125, 149, 159, 180, 198, 224, 243, 272,\r\n                297, 314, 348, 376, 407, 440, 462, 496, 534, 559, 604, 634, 684, 719, 756, 790, 832,\r\n                876, 923, 972, 1024,\r\n            ],\r\n            ECI: [0],\r\n        },\r\n    },\r\n    H: {\r\n        totalDataCodewords: [\r\n            9, 16, 26, 36, 46, 60, 66, 86, 100, 122, 140, 158, 180, 197, 223, 253, 283, 313, 341,\r\n            385, 406, 442, 464, 514, 538, 596, 628, 661, 701, 745, 793, 845, 901, 961, 986, 1054,\r\n            1096, 1142, 1222, 1276,\r\n        ],\r\n        ECCodeWordsPerBlock: [\r\n            17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24,\r\n            30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\r\n        ],\r\n        blocksInGroup1: [\r\n            1, 1, 2, 4, 2, 4, 4, 4, 4, 6, 3, 7, 12, 11, 11, 3, 2, 2, 9, 15, 19, 34, 16, 30, 22, 33,\r\n            12, 11, 19, 23, 23, 19, 11, 59, 22, 2, 24, 42, 10, 20,\r\n        ],\r\n        codewordsInGroup1Block: [\r\n            9, 16, 13, 9, 11, 15, 13, 14, 12, 15, 12, 14, 11, 12, 12, 15, 14, 14, 13, 15, 16, 13,\r\n            15, 16, 15, 16, 15, 15, 15, 15, 15, 15, 15, 16, 15, 15, 15, 15, 15, 15,\r\n        ],\r\n        blocksInGroup2: [\r\n            0, 0, 0, 0, 2, 0, 1, 2, 4, 2, 8, 4, 4, 5, 7, 13, 17, 19, 16, 10, 6, 0, 14, 2, 13, 4, 28,\r\n            31, 26, 25, 28, 35, 46, 1, 41, 64, 46, 32, 67, 61,\r\n        ],\r\n        codewordsInGroup2Block: [\r\n            0, 0, 0, 0, 12, 0, 14, 15, 13, 16, 13, 15, 12, 13, 13, 16, 15, 15, 14, 16, 17, 0, 16,\r\n            17, 16, 17, 16, 16, 16, 16, 16, 16, 16, 17, 16, 16, 16, 16, 16, 16,\r\n        ],\r\n        ModeSize: {\r\n            Numeric: [\r\n                17, 34, 58, 82, 106, 139, 154, 202, 235, 288, 331, 374, 427, 468, 530, 602, 674,\r\n                746, 813, 919, 969, 1056, 1108, 1228, 1286, 1425, 1501, 1581, 1677, 1782, 1897,\r\n                2022, 2157, 2301, 2361, 2524, 2625, 2735, 2927, 3057,\r\n            ],\r\n            Alphanumeric: [\r\n                10, 20, 35, 50, 64, 84, 93, 122, 143, 174, 200, 227, 259, 283, 321, 365, 408, 452,\r\n                493, 557, 587, 640, 672, 744, 779, 864, 910, 958, 1016, 1080, 1150, 1226, 1307,\r\n                1394, 1431, 1530, 1591, 1658, 1774, 1852,\r\n            ],\r\n            Byte: [\r\n                7, 14, 24, 34, 44, 58, 64, 84, 98, 119, 137, 155, 177, 194, 220, 250, 280, 310, 338,\r\n                382, 403, 439, 461, 511, 535, 593, 625, 658, 698, 742, 790, 842, 898, 958, 983,\r\n                1051, 1093, 1139, 1219, 1273,\r\n            ],\r\n            Kanji: [\r\n                4, 8, 15, 21, 27, 36, 39, 52, 60, 74, 85, 96, 109, 120, 136, 154, 173, 191, 208,\r\n                235, 248, 270, 284, 315, 330, 365, 385, 405, 430, 457, 486, 518, 553, 590, 605, 647,\r\n                673, 701, 750, 784,\r\n            ],\r\n            ECI: [0],\r\n        },\r\n    },\r\n};\r\nvar DATA_LOG = {};\r\nvar ERROR_LOOKUP = {\r\n    ERC_NUMERIC_MODE_INVALID_DATA: 'Numeric mode may only contain digits',\r\n    ERC_ALPHANUMERIC_MODE_INVALID_DATA: 'Alphanumeric mode may only contain digits and upper-case letters',\r\n    ERC_BYTE_MODE_INVALID_DATA: 'Some characters not allowed in Byte mode',\r\n    ERC_KANJI_MODE_INVALID_DATA: 'Some characters not allowed in Kanji mode',\r\n    ERC_INPUT_TEXT_TOO_LONG: 'The input value is too long for the selected mode',\r\n    ERC_VERSION_NOT_SUPPORTED: 'QR version with more than one error corretion group is not supported',\r\n};\r\nvar MODE_REGEX = {\r\n    Numeric: /^\\d*$/,\r\n    Alphanmeric: /^[\\dA-Z $%*+\\-./:]*$/,\r\n    Byte: /^[\\x00-\\xff]*$/,\r\n    Kanji: /^[\\p{Script_Extensions=Han}\\p{Script_Extensions=Hiragana}\\p{Script_Extensions=Katakana}]*$/u,\r\n};\r\nvar QRCode = /** @class */ (function () {\r\n    function QRCode(canvasId, data, mode, correctionLevel) {\r\n        if (mode === void 0) { mode = 'Byte'; }\r\n        if (correctionLevel === void 0) { correctionLevel = 'L'; }\r\n        this.canvasId = canvasId; // The HTML canvas's ID to draw the results :: String\r\n        this.data = data; // Data to be encoded :: String\r\n        this.mode = mode; // The type of encoding - depends on which characters are allowed :: String\r\n        this.correctionLevel = correctionLevel;\r\n        var validateResult = this.validateData(''); // fix\r\n        if (!validateResult[0]) {\r\n            throw ERROR_LOOKUP[validateResult[1]];\r\n        }\r\n        this.version = this.getRequiredVersion();\r\n        this.size = this.getSize();\r\n        if (VERSION_DATA[this.correctionLevel].blocksInGroup2[this.version - 1] > 0) {\r\n            console.log(this.version);\r\n            throw ERROR_LOOKUP['ERC_VERSION_NOT_SUPPORTED'];\r\n        }\r\n        log({\r\n            Properties: {\r\n                Size: this.size,\r\n                Version: this.version,\r\n                'Correction Level': this.correctionLevel,\r\n            },\r\n        }, true);\r\n        if (this.canvasId) {\r\n            this.canvasGrid = new _CanvasGrid__WEBPACK_IMPORTED_MODULE_0__.CanvasGrid(this.canvasId, this.size);\r\n        }\r\n    }\r\n    QRCode.prototype.getRequiredVersion = function () {\r\n        var lengths = VERSION_DATA[this.correctionLevel].ModeSize[this.mode];\r\n        var version;\r\n        for (var i = 0; i < lengths.length; i++) {\r\n            if (lengths[i] > this.data.length) {\r\n                version = i + 1;\r\n                break;\r\n            }\r\n        }\r\n        return version;\r\n    };\r\n    QRCode.prototype.getSize = function () {\r\n        return 17 + 4 * this.version; // Why 17?\r\n    };\r\n    // Check if the data conforms to the limits of the encoding type\r\n    QRCode.prototype.validateData = function (data) {\r\n        if (data > VERSION_DATA[this.correctionLevel][39]) {\r\n            return [false, 'ERC_INPUT_TEXT_TOO_LONG'];\r\n        }\r\n        if (!MODE_REGEX[this.mode].test(data)) {\r\n            switch (this.mode) {\r\n                case 'Numeric':\r\n                    return [false, 'ERC_NUMERIC_MODE_INVALID_DATA'];\r\n                case 'Alphanumeric':\r\n                    return [false, 'ERC_ALPHANUMERIC_MODE_INVALID_DATA'];\r\n                case 'Byte':\r\n                    return [false, 'ERC_BYTE_MODE_INVALID_DATA'];\r\n                case 'Kanji':\r\n                    return [false, 'ERC_KANJI_MODE_INVALID_DATA'];\r\n                default:\r\n                    return [false, -1];\r\n            }\r\n        }\r\n        else {\r\n            return [true];\r\n        }\r\n    };\r\n    // Returns the encoded data as a string of binary\r\n    QRCode.prototype.generateCode = function () {\r\n        var _a;\r\n        var codewords = this.getCodeWords();\r\n        // Reed-Solomon Error correction\r\n        /*  https://downloads.bbc.co.uk/rd/pubs/whp/whp-pdf-files/WHP031.pdf\r\n            https://www.thonky.com/qr-code-tutorial/how-create-generator-polynomial\r\n            https://www.thonky.com/qr-code-tutorial/error-correction-coding\r\n        */\r\n        // 0. Split the codewords into groups\r\n        _a = this.getGroups(codewords), this.group1 = _a[0], this.group2 = _a[1];\r\n        log({ 'Group 1': this.group1, 'Group 2': this.group2 });\r\n        // 1. Convert the codewords into base10 and create the polynomial coefficients\r\n        var group1Coefficients = this.getGroupCoefficients(this.group1);\r\n        var group2Coefficients = this.getGroupCoefficients(this.group2);\r\n        var numberOfErrorCorrectionCodeWords = this.getNumberOfErrorCorrectionCodeWords();\r\n        var numberOfCodeWords = this.getTotalNumberOfCodewords();\r\n        var group1Coefficients_Hex = [];\r\n        var group2Coefficients_Hex = [];\r\n        for (var i = 0; i < group1Coefficients.length; i++) {\r\n            group1Coefficients_Hex.push(_util__WEBPACK_IMPORTED_MODULE_3__.intToHex(group1Coefficients[i]));\r\n        }\r\n        for (var i = 0; i < group2Coefficients.length; i++) {\r\n            group2Coefficients_Hex.push(_util__WEBPACK_IMPORTED_MODULE_3__.intToHex(group2Coefficients[i]));\r\n        }\r\n        log({\r\n            numberOfErrorCorrectionCodeWords: numberOfErrorCorrectionCodeWords,\r\n            group1Coefficients: group1Coefficients,\r\n            group1Coefficients_Hex: group1Coefficients_Hex,\r\n            group2Coefficients: group2Coefficients,\r\n            group2Coefficients_Hex: group2Coefficients_Hex,\r\n            numberofCodeWords: numberOfCodeWords,\r\n        });\r\n        var groups = [];\r\n        for (var i = 0; i < group1Coefficients.length; i++) {\r\n            groups[i] = group1Coefficients[i];\r\n        }\r\n        for (var i = 0; i < group2Coefficients.length; i++) {\r\n            groups[group1Coefficients.length + i] = group2Coefficients[i];\r\n        }\r\n        // 2. Get error correction codewords and add to our data codewords\r\n        // https://dev.to/maxart2501/let-s-develop-a-qr-code-generator-part-ii-sequencing-data-4ae\r\n        var ECC = (0,_Polynomial__WEBPACK_IMPORTED_MODULE_1__.getEDC)(groups, numberOfErrorCorrectionCodeWords + numberOfCodeWords);\r\n        var ECC_Hex = [];\r\n        for (var i = 0; i < ECC.length; i++) {\r\n            codewords += this.padCharacterLength(parseInt(ECC['' + i], 10).toString(2));\r\n            ECC_Hex.push(_util__WEBPACK_IMPORTED_MODULE_3__.intToHex(ECC['' + i]));\r\n        }\r\n        log({ ECC: ECC, ECC_Hex: ECC_Hex, codewords: codewords }, true);\r\n        var qrArray = new _QRArray__WEBPACK_IMPORTED_MODULE_2__.QRArray(this, codewords);\r\n        qrArray.addCodewords();\r\n        qrArray.applyMasks();\r\n        qrArray.addTimingPattern();\r\n        qrArray.addFinderPattern();\r\n        qrArray.addErrorLevel();\r\n        qrArray.addSmallFinderPatterns();\r\n        qrArray.addVersionInformation();\r\n        // this.markColumn(qrArray, 2);\r\n        // this.markRow(qrArray, 8);\r\n        // this.markPoint(qrArray, 5, 5);\r\n        return qrArray.array;\r\n    };\r\n    /* Take the qr data and output a binary string formed of the following:\r\n     - 4 bits of the mode\r\n     - Length of the data\r\n     - Binary representation of the data\r\n     - Terminator to mark the end of these attributes\r\n     - Padding\r\n    */\r\n    QRCode.prototype.getCodeWords = function () {\r\n        var codewords = '';\r\n        this.totalBits =\r\n            this.getTotalNumberOfCodewords() * CHARACTER_LENGTH_MAP[this.mode](this.version);\r\n        var bMode = this.getModeForCodewords();\r\n        var bDataLength = this.getLengthForCodewords();\r\n        var bData = this.getDataForCodewords();\r\n        var bTerminator = this.getTerminatorForCodewords(codewords);\r\n        codewords += bMode + bDataLength + bData + bTerminator;\r\n        codewords = this.padCodewords(codewords);\r\n        log({\r\n            bMode: bMode,\r\n            bDataLength: bDataLength,\r\n            bData: bData,\r\n            bTerminator: bTerminator,\r\n            totalBits: this.totalBits,\r\n        }, true);\r\n        return codewords;\r\n    };\r\n    // The encoding mode as a 4 bit binary string\r\n    QRCode.prototype.getModeForCodewords = function () {\r\n        return MODES[this.mode];\r\n    };\r\n    // The number of characters to be encoded, represented as an 8 bit binary string\r\n    QRCode.prototype.getLengthForCodewords = function () {\r\n        var bDataLength = this.data.length.toString(2);\r\n        return this.padCharacterLength(bDataLength);\r\n    };\r\n    // If the total bits is more than the number of bits used, add a terminator, up to 4 bits long\r\n    QRCode.prototype.getTerminatorForCodewords = function (codewords) {\r\n        var bTerminator = '';\r\n        for (var i = 0; i < Math.min(this.totalBits - codewords.length, 4); i++) {\r\n            bTerminator += '0';\r\n        }\r\n        return bTerminator;\r\n    };\r\n    // The input data as a binary string\r\n    QRCode.prototype.getDataForCodewords = function () {\r\n        var output = '';\r\n        // How many bits per codeword depends on the mode\r\n        if (this.mode == 'Byte') {\r\n            // https://www.thonky.com/qr-code-tutorial/byte-mode-encoding\r\n            // Turn each character into binary and add it to the output\r\n            for (var i = 0; i < this.data.length; i++) {\r\n                var bChar = this.padCharacterLength(_util__WEBPACK_IMPORTED_MODULE_3__.toBinary(this.data[i]));\r\n                output += bChar;\r\n                DATA_LOG['bData'] += bChar;\r\n            }\r\n        }\r\n        else if (this.mode == 'Numeric') {\r\n            //https://www.thonky.com/qr-code-tutorial/numeric-mode-encoding\r\n            //https://www.thonky.com/qr-code-tutorial/byte-mode-encoding\r\n            //https://www.thonky.com/qr-code-tutorial/kanji-mode-encoding\r\n        }\r\n        else if ((this.mode = 'AlphaNumeric')) {\r\n        }\r\n        return output;\r\n    };\r\n    // Pad the end of the codewords until the total number of bits is a multiple of 8 and it's long enough\r\n    QRCode.prototype.padCodewords = function (codewords) {\r\n        while (codewords.length % 8 != 0) {\r\n            codewords += '0';\r\n        }\r\n        // If the codewords is still not long enough, add the following until it is:\r\n        var toggle = true;\r\n        while (codewords.length < this.totalBits) {\r\n            if (toggle) {\r\n                codewords += '11101100';\r\n            }\r\n            else {\r\n                codewords += '00010001';\r\n            }\r\n            toggle = !toggle;\r\n        }\r\n        return codewords;\r\n    };\r\n    QRCode.prototype.getGroups = function (codewords) {\r\n        var _a, _b;\r\n        var index = 0, group1, group2;\r\n        _a = this.getGroup1(codewords, index), group1 = _a[0], index = _a[1];\r\n        _b = this.getGroup2(codewords, index), group2 = _b[0], index = _b[1];\r\n        return [group1, group2];\r\n    };\r\n    // First group of codewords\r\n    QRCode.prototype.getGroup1 = function (output, index) {\r\n        var group1 = [];\r\n        // For each block in group 1\r\n        for (var i = 0; i < VERSION_DATA[this.correctionLevel].blocksInGroup1[this.version - 1]; i++) {\r\n            group1.push([]);\r\n            // For each codeword in block\r\n            for (var j = 0; j < VERSION_DATA[this.correctionLevel].codewordsInGroup1Block[this.version - 1]; j++) {\r\n                // Add the codeword to the block\r\n                group1[i].push(output.slice(index * 8, (index + 1) * 8));\r\n                index += 1;\r\n            }\r\n        }\r\n        return [group1, index];\r\n    };\r\n    // Second group codewords\r\n    QRCode.prototype.getGroup2 = function (output, index) {\r\n        var group2 = [];\r\n        // For each block in group 2\r\n        for (var i = 0; i < VERSION_DATA[this.correctionLevel].blocksInGroup2[this.version - 1]; i++) {\r\n            group2.push([]);\r\n            // For each codeword in block\r\n            for (var j = 0; j < VERSION_DATA[this.correctionLevel].codewordsInGroup2Block[this.version - 1]; j++) {\r\n                // Add the codeword to the block\r\n                group2[i].push(output.slice(index * 8, (index + 1) * 8));\r\n                index += 1;\r\n            }\r\n        }\r\n        return [group2, index];\r\n    };\r\n    // Polynomial for the group\r\n    QRCode.prototype.getGroupCoefficients = function (group) {\r\n        var coefficients = [];\r\n        for (var i = 0; i < group.length; i++) {\r\n            for (var j = 0; j < group[i].length; j++) {\r\n                coefficients.push(parseInt(group[i][j], 2));\r\n            }\r\n        }\r\n        return coefficients;\r\n    };\r\n    // Takes a character, in binary, and returns a padded string depending on the mode and version\r\n    QRCode.prototype.padCharacterLength = function (bCharacter) {\r\n        var characterLength = CHARACTER_LENGTH_MAP[this.mode](this.version);\r\n        while (bCharacter.length % characterLength != 0) {\r\n            bCharacter = '0' + bCharacter;\r\n        }\r\n        return bCharacter;\r\n    };\r\n    QRCode.prototype.getNumberOfErrorCorrectionCodeWords = function () {\r\n        return (VERSION_DATA[this.correctionLevel].ECCodeWordsPerBlock[this.version - 1] *\r\n            (VERSION_DATA[this.correctionLevel].blocksInGroup1[this.version - 1] +\r\n                VERSION_DATA[this.correctionLevel].blocksInGroup2[this.version - 1]));\r\n    };\r\n    QRCode.prototype.getTotalNumberOfCodewords = function () {\r\n        // Found using // https://www.thonky.com/qr-code-tutorial/error-correction-table\r\n        var blocksInGroup1 = VERSION_DATA[this.correctionLevel].blocksInGroup1[this.version - 1]; // Index 0 is version 1 data\r\n        var codewordsInGroup1Block = VERSION_DATA[this.correctionLevel].codewordsInGroup1Block[this.version - 1];\r\n        var blocksInGroup2 = VERSION_DATA[this.correctionLevel].blocksInGroup2[this.version - 1];\r\n        var codewordsInGroup2Block = VERSION_DATA[this.correctionLevel].codewordsInGroup2Block[this.version - 1];\r\n        return blocksInGroup1 * codewordsInGroup1Block + blocksInGroup2 * codewordsInGroup2Block;\r\n    };\r\n    QRCode.prototype.markColumn = function (qrArray, x) {\r\n        for (var i = 0; i < qrArray.array.length; i++) {\r\n            if (i % this.size == x) {\r\n                qrArray.array[i] = 'X';\r\n            }\r\n        }\r\n    };\r\n    QRCode.prototype.markRow = function (qrArray, y) {\r\n        for (var i = 0; i < qrArray.array.length; i++) {\r\n            if (Math.floor(i / this.size) == y) {\r\n                qrArray.array[i] = 'X';\r\n            }\r\n        }\r\n    };\r\n    QRCode.prototype.markPoint = function (qrArray, x, y) {\r\n        for (var i = 0; i < qrArray.array.length; i++) {\r\n            if (Math.floor(i / this.size) == y && i % this.size == x) {\r\n                qrArray.array[i] = 'X';\r\n            }\r\n        }\r\n    };\r\n    // Displays the QR code on the canvas\r\n    QRCode.prototype.display = function () {\r\n        var _this = this;\r\n        var output = this.generateCode();\r\n        output.forEach(function (value, index) {\r\n            var _a;\r\n            _this.canvasGrid.fillCell(index, (_a = CELL_COLORS[value]) !== null && _a !== void 0 ? _a : DEFAULT_COLOR);\r\n        });\r\n        return output;\r\n    };\r\n    return QRCode;\r\n}());\r\n\r\n// Helper functions\r\n// Returns the character limit for the mode and correctionLevel\r\nfunction getCharacterLimit(mode, correctionLevel) {\r\n    return Math.max(VERSION_DATA[correctionLevel].ModeSize[mode]);\r\n}\r\n// Adds data to the global log\r\nfunction log(dict, print) {\r\n    if (print === void 0) { print = false; }\r\n    for (var _i = 0, _a = Object.keys(dict); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        DATA_LOG[key] = dict[key];\r\n    }\r\n    if (print) {\r\n        printLog();\r\n    }\r\n}\r\n// Prints the global log\r\nfunction printLog() {\r\n    console.log('DATA_LOG: ', DATA_LOG);\r\n}\r\n\n\n//# sourceURL=webpack://my-webpack-project/./src/QRCode.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"QR\": () => (/* reexport safe */ _QR__WEBPACK_IMPORTED_MODULE_0__.QR)\n/* harmony export */ });\n/* harmony import */ var _QR__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./QR */ \"./src/QR.ts\");\n\r\n\n\n//# sourceURL=webpack://my-webpack-project/./src/index.ts?");

/***/ }),

/***/ "./src/util.ts":
/*!*********************!*\
  !*** ./src/util.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"binaryToHex\": () => (/* binding */ binaryToHex),\n/* harmony export */   \"intToHex\": () => (/* binding */ intToHex),\n/* harmony export */   \"toBinary\": () => (/* binding */ toBinary)\n/* harmony export */ });\n// Converts a string to binary\r\nfunction toBinary(sInput) {\r\n    sInput = sInput.toString();\r\n    var output = '';\r\n    for (var i = 0; i < sInput.length; i++) {\r\n        output += sInput[i].charCodeAt(0).toString(2);\r\n    }\r\n    return output;\r\n}\r\n// Converts a binary string to hexadecimal\r\nfunction binaryToHex(sBinary) {\r\n    return parseInt(sBinary, 2).toString(16);\r\n}\r\n// Converts an int to hexadecimal\r\nfunction intToHex(iInt) {\r\n    return parseInt(iInt, 10).toString(16);\r\n}\r\n\n\n//# sourceURL=webpack://my-webpack-project/./src/util.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});